name: Release Management

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
        type: string
      release_type:
        description: 'Type of release'
        required: true
        default: 'release'
        type: choice
        options:
          - release
          - prerelease
          - draft
      deploy_to_production:
        description: 'Deploy to production after release'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Create Release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      release_id: ${{ steps.create_release.outputs.id }}
      tag_name: ${{ steps.prepare.outputs.tag_name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare release
        id: prepare
        run: |
          TAG_NAME="${{ github.event.inputs.version }}"
          if [[ ! $TAG_NAME =~ ^v[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
            echo "Invalid version format. Use semantic versioning (e.g., v1.2.3)"
            exit 1
          fi
          
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "version=${TAG_NAME#v}" >> $GITHUB_OUTPUT

      - name: Create and push tag
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git tag ${{ steps.prepare.outputs.tag_name }}
          git push origin ${{ steps.prepare.outputs.tag_name }}

      - name: Generate changelog
        id: changelog
        run: |
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          CURRENT_TAG="${{ steps.prepare.outputs.tag_name }}"
          
          if [ -n "$PREVIOUS_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
          fi
          
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.prepare.outputs.tag_name }}
          release_name: HR System ${{ steps.prepare.outputs.tag_name }}
          body: |
            ## What's New in this Release
            
            ${{ steps.changelog.outputs.CHANGELOG }}
            
            ## Docker Images
            - `ghcr.io/${{ github.repository }}:${{ steps.prepare.outputs.version }}`
            - `ghcr.io/${{ github.repository }}:latest`
            
            ## Installation
            ```bash
            docker pull ghcr.io/${{ github.repository }}:${{ steps.prepare.outputs.version }}
            ```
            
            ## Full Changelog
            **Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ steps.changelog.outputs.previous_tag }}..${{ steps.prepare.outputs.tag_name }}
          draft: ${{ github.event.inputs.release_type == 'draft' }}
          prerelease: ${{ github.event.inputs.release_type == 'prerelease' }}

  # Build and Push Release Image
  docker-release:
    name: Build Release Docker Image
    runs-on: ubuntu-latest
    needs: [create-release]
    
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-release.outputs.tag_name }}

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.create-release.outputs.tag_name }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.create-release.outputs.tag_name }}
            type=semver,pattern={{major}},value=${{ needs.create-release.outputs.tag_name }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Security Scan for Release
  security-scan:
    name: Security Scan Release Image
    runs-on: ubuntu-latest
    needs: [docker-release, create-release]
    
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'ghcr.io/${{ github.repository }}:${{ needs.create-release.outputs.tag_name }}'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check for critical vulnerabilities
        run: |
          # Parse SARIF and check for critical vulnerabilities
          if grep -q '"level": "error"' trivy-results.sarif; then
            echo "Critical vulnerabilities found in release image!"
            echo "Please review the security scan results before proceeding with deployment."
            exit 1
          fi

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [docker-release, security-scan, create-release]
    environment: production
    if: ${{ github.event.inputs.deploy_to_production == 'true' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-release.outputs.tag_name }}

      - name: Deploy to production
        run: |
          echo "Deploying version ${{ needs.create-release.outputs.tag_name }} to production..."
          # Add your production deployment commands here
          # Examples:
          # kubectl set image deployment/hr-system hr-system=ghcr.io/${{ github.repository }}:${{ needs.create-release.outputs.tag_name }}
          # kubectl rollout status deployment/hr-system
          # 
          # Or for Docker Compose:
          # export IMAGE_TAG=${{ needs.create-release.outputs.tag_name }}
          # docker-compose -f docker-compose.prod.yml up -d
          
          echo "Production deployment commands would run here"

      - name: Post-deployment health check
        run: |
          echo "Running post-deployment health checks..."
          # Add health check commands here
          # Examples:
          # curl -f $PRODUCTION_URL/health
          # ./scripts/health-check.sh
          
          echo "Health check commands would run here"

      - name: Update deployment status
        run: |
          echo "Updating deployment status..."
          # Update external systems about successful deployment
          # Examples:
          # Update monitoring dashboards
          # Update deployment tracking systems
          # Send notifications to relevant teams

  # Release Validation
  release-validation:
    name: Release Validation
    runs-on: ubuntu-latest
    needs: [create-release, docker-release, security-scan]
    if: always()
    
    steps:
      - name: Validate release artifacts
        run: |
          echo "Validating release artifacts..."
          
          # Check if GitHub release was created
          if [ "${{ needs.create-release.result }}" != "success" ]; then
            echo "GitHub release creation failed"
            exit 1
          fi
          
          # Check if Docker image was built and pushed
          if [ "${{ needs.docker-release.result }}" != "success" ]; then
            echo "Docker image build/push failed"
            exit 1
          fi
          
          # Check security scan results
          if [ "${{ needs.security-scan.result }}" != "success" ]; then
            echo "Security scan failed or found critical vulnerabilities"
            exit 1
          fi
          
          echo "All release artifacts validated successfully"

      - name: Generate release summary
        run: |
          echo "## Release Summary" > release-summary.md
          echo "" >> release-summary.md
          echo "- **Version**: ${{ needs.create-release.outputs.tag_name }}" >> release-summary.md
          echo "- **Release Type**: ${{ github.event.inputs.release_type }}" >> release-summary.md
          echo "- **GitHub Release**: ${{ needs.create-release.result }}" >> release-summary.md
          echo "- **Docker Image**: ${{ needs.docker-release.result }}" >> release-summary.md
          echo "- **Security Scan**: ${{ needs.security-scan.result }}" >> release-summary.md
          echo "- **Production Deployment**: ${{ needs.deploy-production.result || 'Skipped' }}" >> release-summary.md
          echo "" >> release-summary.md
          echo "### Docker Images" >> release-summary.md
          echo "- \`ghcr.io/${{ github.repository }}:${{ needs.create-release.outputs.tag_name }}\`" >> release-summary.md
          echo "- \`ghcr.io/${{ github.repository }}:latest\`" >> release-summary.md

      - name: Upload release summary
        uses: actions/upload-artifact@v3
        with:
          name: release-summary
          path: release-summary.md

  # Release Notification
  notify-release:
    name: Release Notifications
    runs-on: ubuntu-latest
    needs: [release-validation, deploy-production]
    if: always()
    
    steps:
      - name: Send release notification
        run: |
          echo "Sending release notification for ${{ needs.create-release.outputs.tag_name }}..."
          
          # Determine notification message based on results
          if [ "${{ needs.release-validation.result }}" == "success" ]; then
            MESSAGE="HR System ${{ needs.create-release.outputs.tag_name }} released successfully!"
            if [ "${{ needs.deploy-production.result }}" == "success" ]; then
              MESSAGE="$MESSAGE Deployed to production."
            fi
          else
            MESSAGE="HR System ${{ needs.create-release.outputs.tag_name }} release had issues. Please check the workflow."
          fi
          
          echo "Notification message: $MESSAGE"
          
          # Add notification logic here (Slack, Discord, Email, etc.)
          # Examples:
          # curl -X POST -H 'Content-type: application/json' \
          #   --data "{\"text\":\"$MESSAGE\"}" \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
          #
          # curl -X POST -H 'Content-Type: application/json' \
          #   -d "{\"content\":\"$MESSAGE\"}" \
          #   ${{ secrets.DISCORD_WEBHOOK_URL }}

      - name: Update release tracking
        run: |
          echo "Updating release tracking systems..."
          # Update external release tracking systems
          # Examples:
          # JIRA ticket updates
          # Confluence documentation updates
          # Internal dashboards
